# Python的循环语句及包导入相应内容

Python的循环

while语句及for语句:

1.`while`语句:</br>
　`while`与`if`语句类似,当后面的表达式成立时,执行后续代码块,也可以和`else`配合使用</br>
　不同的是,`if`语句后续执行完代码块后是会退出`if`语句,而`while`会一直执行后续代码块

●当需要使用递归操作时,多使用`while`,其余情况使用`for`居多

2.for语句</br>
　for循环主要是用来遍历/循环 序列或者集合、字典

>print函数默认打印出的每个元素是换行的,当要实现同一行显示,则可以表示为print(x,end = ‘’)

`for`也可以与`else`配合使用

`break`可以跳出循环,`break`后的所有代码都不会执行,即使后续有`else`也不会执行,且一个`break`只会退出一层循环</br>
`continue`可以跳过单个条件的循环,当前的代码块不会执行

python中`for(i= 0; i<10,i++){`</br>
　　　　　`}`</br>
的替代方式是:`for x in range(0,10)`

注:</br>
　1)`range(0,10)`只会标示0-9,后面的10标示偏移量</br>
当要求是只打印偶数时,可以改为`range(0,10,2)`</br>
最后一个数字表示的含义为`步长`</br>
　2)当要表示从10到0的递减序列,可以写成`range(10,0,-2)`</br>
　注:最后一个步长可以是负数

`a = [1,2,3,4,5,6,7,8]`</br>
当要求是打印a中所有的奇数这一要求时,除了可以使用`for`循环外,还可以使用步长的概念,即:</br>
`b = a[0 : len(a) : 2]`; 最后一个元素即为步长

3.python项目的组织结构</br>
`包—>模块—>类`(函数变量属于类中的特性)

python中使用文件夹来表示一个包的概念

命名空间用于区分不同包的同名模块,可以用`包名.模块名`的方式

python区分普通文件夹和包:是包的话,一定要有一个`__init__.py`,其本身也是一个模块

`import`用于导入模块,即`import`后面只能跟上模块名</br>
注：</br>
　1)import只能导入模块,不能直接导入模块内的变量或者函数</br>
　2)要调用模块中的变量或者函数必须要用`．`的方式</br>
　3)可以使用`as`关键字将前面的组织路径重命名为一个变量名,即`import t.c7 as new_bag` ,后续使用木块内的函数或者变量,只需通过`new_bag.xxx`进行获取即可

可以使用该方式,在c8文件中使用c7的内容(c7和c8同级)</br>
![1-1](Snip20180224_2.png)
￼


当c8与c7不在同级时</br>
![1-2](Snip20180224_3.png)
￼

可以使用`from 模块路径 import 具体变量`  简化</br>
后续可以直接使用具体变量</br>
即以上可以改写为`from t.c7 import a`,后续可以直接使用a

当一个模块中有多个变量时,可以使用 `from t.c7 import *`的方式导入c7中的全部变量,,但不建议这么写
![1-3](Snip20180224_4.png)

￼
可以在c7文件中添加`__all__ = `的方式控制当其他文件中使用*导入时导入的对象,同样也可以导入包内的全部模块</br>
`__all__`称为模块的内置模块或模块的内置属性

p.s 可以通过`file.exclude`中添加pycache方式来令该文件隐藏

可以在import中通过逗号(,)的方式,将模块中的变量或方法一次导入

可以通过在末尾添加`反斜杠(\)`的方式实现代码换行(不推荐)</br>
推荐在被导入的变量前加括号`()`的方式进行换行

可以直接导入一个包,会自动导入包内的全部模块

`__init__.py`文件会在导入包或者模块时自动运行,无需手动运行</br>
作用:</br>
　1)在`__init__.py`文件中添加`__all__ = [‘模块名’]`的方式,在其他模块使用`*`导入模块时,限制调用包内的某些模块</br>
　2)可以在`__init__.py`中批量导入公用的库

1)包和模块是不会被重复导入的</br>
2)要防止循环导入

python中导入一个模块的时候,就会执行该模块的代码

`dir函数`用于返回当前模块的变量</br>
(当想要查看某个类中的模块变量时,可以使用`dir(sys)`等,可以查看sys内的模块变量)

内置函数:</br>
`__name__  `:当前模块的完整名称(命名空间)</br>
`__package__`:包名</br>
`__file__`:当前模块在系统中的物理路径</br>
`__doc__`:模块的文档注释内容

若一个py文件被当做入口文件时,</br>
`__name__`结果都为`__main__`</br>
`__package__`结果为当前模块是不属于任何包的</br>
`__file__`则直接为`当前文件名.py`(即运行时,python后接的东西)</br>

```
__name__内置函数的经典作用

if __name__ == ‘__main__’</br>
	代码块
“
来判断该py文件是入口文件还是导入的模块
```

`python -m` 可以将一个py文件当做一个模块处理,值得注意的是,需要将文件路径调至该级的上一级

模块的顶级包是与入口文件的位置有关....

绝对导入的绝对路径必须从顶级包开始</br>
相对路径中 `.`标示当前目录,`..`标示上级目录,`…`标示上上级目录</br>
可以通过`from import`的方式进行相对导入,但无法在入口文件使用相对导入,原因是若直接使用,会直接将`.`的部分转换为`__name__`,而顶级包的内置函数`__name__`为`__main__`,从而找不到路径,且不能超过顶级包